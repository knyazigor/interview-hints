## Redux

Redux - это библиотека управления состоянием для JavaScript-приложений, основанная на архитектуре Flux. Она используется для управления состоянием приложения и обеспечивает предсказуемость, централизацию и отслеживаемость состояния.

### Три главных принципа Redux:
1. Единое состояние (Single source of truth): Вся информация о состоянии приложения хранится в единственном объекте - "store". Это упрощает отслеживание и обновление состояния приложения.

2. Состояние только для чтения (State is read-only): Состояние в Redux является неизменяемым. Единственный способ изменить состояние - это создать новую копию с помощью чистых функций, называемых "reducers".

3. Изменения с помощью чистых функций (Changes are made with pure functions): Для изменения состояния в Redux используются чистые функции, называемые "reducers". Они принимают текущее состояние и действие (action) и возвращают новое состояние. Это делает изменения состояния предсказуемыми и легко тестируемыми.

### Redux работает на основе следующих ключевых элементов:

1. Store (Хранилище): Хранилище представляет собой объект, который содержит состояние приложения. Оно является единственным источником правды для состояния приложения. Чтобы создать хранилище в Redux, используется функция createStore:
```jsx
import { createStore } from 'redux';

const initialState = {
  counter: 0,
};

function reducer(state = initialState, action) {
  switch(action.type) {
    case 'INCREMENT':
      return { ...state, counter: state.counter + 1 };
    case 'DECREMENT':
      return { ...state, counter: state.counter - 1 };
    default:
      return state;
  }
}

const store = createStore(reducer);
```

2. Actions (Действия): Действия представляют собой объекты, которые описывают события или изменения в приложении. Они должны иметь свойство type, которое указывает тип действия. Действия создаются с помощью функций, называемых "action creators". Вот примеры:
```jsx
function increment() {
  return { type: 'INCREMENT' };
}

function decrement() {
  return { type: 'DECREMENT' };
}
```

3. Reducers (Редукторы): Редукторы определяют, какое изменение должно произойти в состоянии приложения в ответ на действие. Они являются чистыми функциями, которые принимают текущее состояние и действие, и возвращают новое состояние. В примере выше reducer является редуктором.

4. Dispatch (Отправка): Для того чтобы изменить состояние приложения, действие должно быть отправлено в хранилище с помощью функции dispatch:
```jsx
store.dispatch(increment());
store.dispatch(decrement());
```

5. Subscribe (Подписка): Вы можете подписаться на изменения состояния приложения, используя функцию subscribe. Когда состояние изменяется, вызывается зарегистрированный обработчик:
```jsx
store.subscribe(() => {
  console.log(store.getState());
});
```

Это основная схема работы Redux. Действия инициируются представлением, передаются в редукторы, которые обновляют состояние в хранилище, и представление получает обновленное состояние из хранилища для отображения пользователю.

`State` - центральзованное хранение данных, источник истины для всего приложения. `State` иммумтабелен, доступен только для чтения.
Когда пользователь взаимодействует с приложением, состояние изменяется, вызывая функцию-обработчик (`action`), которая в свою очередь вызывает функцию-редуктор (`reducer`), которая обновляет состояние. Затем Redux-библиотека перерисовывает компоненты с новым состоянием.

`UI -> (dispatch) -> Action -> Reducer -> Store -> (subcribe) -> UI`

### connect

1. `connect` в Redux - это функция высшего порядка (Higher-Order Function), которая используется для связывания компонента React с хранилищем Redux. Она позволяет компоненту получать доступ к состоянию и действиям Redux. Функция connect возвращает новую обертку компонента, который подключен к Redux.

2. `connect` играет ключевую роль в архитектуре приложения на основе Redux. Она обеспечивает связь между компонентами React и хранилищем Redux, позволяя компонентам получать и обновлять состояние приложения. connect также автоматически подписывается на изменения состояния и обновляет компонент, когда состояние изменяется.

3. `connect` - это HOC (Higher-Order Component), или компонент высшего порядка. HOC - это функция, которая принимает компонент и возвращает новый обернутый компонент с дополнительными свойствами и функциональностью. В случае connect, она оборачивает компонент React и предоставляет ему доступ к состоянию и действиям Redux через props. connect принимает две функции: mapStateToProps и mapDispatchToProps. Первая функция определяет, какие части состояния Redux должны быть доступны в компоненте, а вторая функция определяет, какие действия должны быть доступны в компоненте.

### Actions 
Действия (actions) в Redux - это объекты, которые описывают события или изменения, происходящие в приложении. Они являются единственным источником информации для обновления состояния в хранилище Redux.

Действия в Redux обычно имеют свойство type, которое указывает тип действия. Они также могут содержать дополнительные данные, необходимые для обработки этого действия. Например:
```jsx
const incrementAction = {
  type: 'INCREMENT',
};

const addTodoAction = {
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Buy groceries',
  },
};
```

Действия создаются с помощью функций, называемых "action creators". Они являются чистыми функциями, которые возвращают объекты действий. Вот пример:

```jsx
function increment() {
  return {
    type: 'INCREMENT',
  };
}

function addTodo(id, text) {
  return {
    type: 'ADD_TODO',
    payload: {
      id,
      text,
    },
  };
}
```

Действия передаются в хранилище Redux через функцию dispatch, и редукторы используют их для обновления состояния приложения. При обработке действий в редукторах важно создавать новые объекты состояния, а не изменять существующее состояние напрямую. Это гарантирует, что Redux сохраняет предсказуемость и непрерывность работы.

### Reducers
Редукторы (reducers) в Redux - это функции, которые определяют, какое изменение должно произойти в состоянии приложения в ответ на действие. Редукторы являются чистыми функциями, которые принимают текущее состояние и действие, и возвращают новое состояние.

Основные правила, которым должны соответствовать редукторы:

1. Редуктор должен быть чистой функцией без побочных эффектов. Он не должен изменять существующее состояние или выполнять асинхронные операции.

2. Редуктор должен всегда возвращать новый объект состояния. Нельзя изменять существующее состояние напрямую. Для создания нового состояния рекомендуется использовать оператор расширения объекта (...) или функции библиотеки ImmutableJS.

3. Если действие не соответствует редуктору, редуктор должен вернуть текущее состояние без изменений.

Пример реализации редуктора с использованием switch/case:

```jsx
const initialState = {
  counter: 0,
};

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, counter: state.counter + 1 };
    case 'DECREMENT':
      return { ...state, counter: state.counter - 1 };
    default:
      return state;
  }
}
```

**Redux Toolkit** - это официальное расширение Redux, которое предоставляет удобные утилиты для упрощения разработки Redux-приложений. Оно включает в себя функцию createSlice, которая автоматически генерирует редуктор и действия на основе определенного объекта состояния и набора "мутационных" методов.

Пример использования Redux Toolkit:
```jsx
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: {
    increment: (state) => state + 1,
    decrement: (state) => state - 1,
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

Работа с редуктором с использованием принципа открытости/закрытости (SOLID) означает, что редуктор должен быть расширяемым для добавления новых функциональностей без изменения существующего кода. Это можно достичь путем комбинации редукторов с использованием функции combineReducers из Redux.

Пример работы с несколькими редукторами с использованием combineReducers:
```jsx
import { combineReducers } from 'redux';

function counterReducer(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    default:
      return state;
  }
}

function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'REMOVE_TODO':
      return state.filter((todo) => todo.id !== action.payload);
    default:
      return state;
  }
}

const rootReducer = combineReducers({
  counter: counterReducer,
  todos: todosReducer,
});

export default rootReducer;
```

### Middleware 
Middleware в Redux - это функции, которые расширяют функциональность хранилища (store) Redux. Они предоставляют способ для изменения или перехвата действий (actions) перед тем, как они достигнут редьюсеров (reducers). Middleware может выполнять различные задачи, такие как логирование, асинхронные операции, маршрутизацию и другие побочные эффекты.

Важно понимать, что middleware в Redux работает на основе конвейерной модели. Действия проходят через middleware в определенной последовательности, и каждый middleware имеет доступ к действию и состоянию хранилища до и после его обработки.

Возможность написания собственного middleware в Redux позволяет разработчикам настраивать и расширять функциональность хранилища по своему усмотрению. Написание middleware включает определение функции, которая принимает три параметра: store, next и action. Middleware может изменять действие, передавать его следующему middleware через next или прекратить его обработку.

Глубокое понимание концепции middleware включает понимание порядка выполнения middleware в цепочке, управление прохождением действий через middleware, использование методов store.dispatch и store.getState, а также реализацию различных функций middleware для различных задач.

Middleware является мощным инструментом в Redux, который позволяет разработчикам управлять потоком данных и добавлять дополнительную логику к хранилищу Redux.

Вот пример простого middleware в Redux:

```jsx
const myMiddleware = store => next => action => {
  // Логируем действие перед его обработкой
  console.log('Dispatching action:', action);

  // Передаем действие следующему middleware или редьюсеру
  const result = next(action);

  // Логируем обновленное состояние после обработки действия
  console.log('Updated state:', store.getState());

  // Возвращаем результат обработки действия
  return result;
};

// Использование middleware при создании хранилища Redux
const store = createStore(
  rootReducer,
  applyMiddleware(myMiddleware)
);
```

В этом примере myMiddleware - это middleware функция. Она принимает store в качестве первого параметра, next в качестве второго параметра и action в качестве третьего параметра. Внутри middleware мы можем выполнять различные действия, такие как логирование, манипуляции с действием или состоянием, асинхронные операции и т.д.

Middleware в Redux работает по принципу цепочки вызовов функций. Каждое middleware может передать действие следующему middleware или редьюсеру, используя next(action). Это позволяет контролировать поток данных и вносить изменения перед и после обработки действия.

В приведенном примере middleware логирует действие перед его обработкой и обновленное состояние после обработки. Вы можете настроить middleware в соответствии с вашими потребностями и добавлять дополнительную логику внутрь функции.

### Selectors 
Селекторы (selectors) в Redux - это функции, которые используются для извлечения данных из состояния хранилища (store). Они предоставляют удобный способ получить определенные части данных из сложного объекта состояния Redux.

1. Понимание назначения селекторов:
   Селекторы позволяют абстрагироваться от структуры состояния Redux и получать только необходимые данные. Они предоставляют интерфейс для получения данных из хранилища, что делает код более модульным, удобным для тестирования и облегчает поддержку при изменении структуры состояния.

2. Возможность объяснить на своих словах:
   Селекторы в Redux - это функции, которые помогают извлекать данные из хранилища Redux. Они принимают состояние хранилища в качестве аргумента и возвращают запрошенные данные. Это позволяет легко получать и использовать только нужные данные в компонентах или других частях приложения.

3. Глубокое понимание назначения селекторов:
   Глубокое понимание селекторов включает понимание их роли в архитектуре Redux. Селекторы помогают избежать прямого доступа к состоянию хранилища из компонентов, что делает код более независимым от структуры состояния Redux. Они также могут использоваться для объединения, трансформации или вычисления данных из нескольких частей состояния.

4. Возможность написания сложных селекторов:
   Вот пример кода, демонстрирующий написание сложного селектора в Redux с использованием библиотеки Reselect:

```jsx
import { createSelector } from 'reselect';

// Селекторы для извлечения данных из состояния Redux
const getUsers = state => state.users;
const getFilter = state => state.filter;

// Сложный селектор, объединяющий данные из нескольких селекторов
const getFilteredUsers = createSelector(
  getUsers,
  getFilter,
  (users, filter) => {
    // Применяем фильтр к списку пользователей
    return users.filter(user => user.name.includes(filter));
  }
);

// Использование сложного селектора в компоненте
const mapStateToProps = state => {
  return {
    filteredUsers: getFilteredUsers(state)
  };
};
```

В этом примере getUsers и getFilter - это простые селекторы для извлечения данных из состояния Redux. getFilteredUsers - сложный селектор, который объединяет данные из getUsers и getFilter и применяет фильтр к списку пользователей. Затем он возвращает отфильтрованный список пользователей.

Сложные селекторы могут быть полезными в случае, когда вам нужно объединить, трансформировать или вычислить данные из нескольких частей состояния. Библиотека Reselect предоставляет удобные инструменты для создания сложных селекторов и оптимизации их производительности.

### Альтернативы 
Как альтернатива Redux, одним из популярных инструментов является MobX. MobX - это библиотека для управления состоянием приложения в JavaScript. Вот некоторые основные различия между MobX и Redux:

1. Подход к управлению состоянием:
   - Redux: Redux основан на концепции однонаправленного потока данных. Состояние хранится в единственном объекте, называемом "хранилищем" (store), и изменения состояния осуществляются путем отправки "действий" (actions) в хранилище, которые обрабатываются "редьюсерами" (reducers).
   - MobX: MobX предлагает "реактивный" подход к управлению состоянием. Он использует наблюдение (observables) и "реакции" (reactions) для автоматического обновления компонентов при изменении состояния.

2. Код:
   - Redux: Redux имеет более явное определение структуры и логики хранилища с использованием действий, редьюсеров и селекторов. Это может потребовать больше кода для настройки и поддержки.
   - MobX: MobX предоставляет более гибкий подход. Он позволяет использовать декораторы или функции для определения наблюдаемых данных и автоматического обновления компонентов при изменении этих данных. Это может сократить объем кода и упростить его понимание.

3. Избирательность обновления:
   - Redux: Redux обновляет все компоненты, подписанные на изменения состояния, даже если не все данные, которые они используют, изменились. Это может привести к избыточным перерисовкам компонентов.
   - MobX: MobX обновляет только те компоненты, которые реально зависят от измененных данных. Это делает обновление более эффективным и позволяет избежать избыточных перерисовок.

4. Обучение и простота использования:
   - Redux: Redux имеет более строгий набор правил и концепций, что может потребовать некоторого времени и усилий для понимания и освоения.
   - MobX: MobX предлагает более простой и интуитивно понятный подход. Он имеет меньше концепций и требует меньше кода для настройки и использования.

Оба Redux и MobX имеют свои преимущества и подходят для разных сценариев. Redux обеспечивает более явную структуру и предсказуемость, что может быть полезно для крупных проектов с множеством разработчиков. MobX, с другой стороны, предлагает более гибкий и простой подход, особенно для небольших или средних проектов. Выбор между Redux и MobX зависит от потребностей вашего проекта и предпочтений разработчиков.

### RTK

В Redux Toolkit `slice` (срез) является концептуальным блоком для организации кода и управления состоянием в Redux.

`slice` - это функция, предоставляемая Redux Toolkit, которая объединяет в себе определение редьюсера и создание связанных действий (`actions`). Она позволяет определить начальное состояние, редьюсер для обработки действий и генерацию связанных действий автоматически.

При использовании `slice`, Redux Toolkit автоматически генерирует именованные действия (`action creators`) для обновления состояния и редьюсер, который обрабатывает эти действия и возвращает новое состояние. Это позволяет упростить и ускорить процесс написания кода, связанного с Redux.

Каждый `slice` имеет свое собственное имя и может быть объединен с другими slice'ами, чтобы создать корневой редьюсер для хранения и управления состоянием всего приложения.