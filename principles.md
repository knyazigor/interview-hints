Применение этих принципов позволяет создавать модульный, гибкий и легко поддерживаемый код в JavaScript.

## OOP
Основные принципы объектно-ориентированного программирования (ООП) в привязке к JavaScript включают:

### 1. Инкапсуляция
Скрытие внутренней реализации объекта и предоставление публичного интерфейса для взаимодействия с ним.

### 2. Наследование
Возможность создания новых классов на основе существующих с переиспользованием их свойств и методов.

### 3. Полиморфизм
Возможность использования одного и того же интерфейса для различных типов данных или классов.

### 4. Абстракция
Создание абстрактных классов или интерфейсов, которые определяют общие свойства и методы для более конкретных классов.

### 5. Композиция
Составление объектов из более мелких и независимых компонентов для создания более сложного функционала.

## SOLID
### S — Принцип единственной ответственности (Single Responsibility Principle, SRP):
Каждый класс (модуль, компонент) должен иметь только одну зону ответственности.
Разделение функциональности на отдельные модули, компоненты или классы, чтобы каждый из них отвечал только за одну конкретную задачу.

Принцип единственной ответственности:
- помогает разбивать и декомпозировать задачи по одной на модуль;
- уменьшает количество модулей, которые надо изменить при изменении требований;
- ограничивает влияние изменений, помогая контролировать сложность системы.

### O — Принцип открытости/закрытости (Open/Closed Principle, OCP):
Классы должны быть открыты для расширения, но закрыты для изменения.
Использование наследования, интерфейсов и композиции для создания модулей и компонентов, которые можно легко расширять новым функционалом без изменения существующего кода.

Принцип открытости-закрытости:
- заставляет проектировать модули так, чтобы они делали только одну вещь и делали её хорошо;
- побуждает связывать сущности через абстракции (а не реализацию) там, где могут поменяться бизнес-требования;
- обращает внимание проектировщиков на места стыка и взаимодействие сущностей;
- позволяет сократить количество кода, который необходимо менять при изменении бизнес-требований;
- делает внесение изменений безопасным и относительно дешёвым.

### L — Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP):
Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.
Правильное использование наследования и полиморфизма, чтобы подклассы могли быть использованы вместо своих суперклассов без нарушения ожидаемого поведения.
Простыми словами — классы-наследники не должны противоречить базовому классу. Например, они не могут предоставлять интерфейс ýже базового. Поведение наследников должно быть ожидаемым для функций, которые используют базовый класс.

Принцип подстановки Барбары Лисков:
- помогает проектировать систему, опираясь на поведение модулей;
- вводит ограничения и правила наследования объектов, чтобы их потомки не противоречили базовому поведению;
- делает поведение модулей последовательным и предсказуемым;
- помогает избегать дублирования, выделять общую для нескольких модулей функциональность в общий интерфейс;
- позволяет выявлять при проектировании проблемные абстракции и скрытые связи между сущностями.

### I — Принцип разделения интерфейса (Interface Segregation Principle, ISP):
Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.
Разделение крупных интерфейсов на более мелкие, чтобы клиенты могли зависеть только от необходимых им методов или свойств.

Принцип разделения интерфейса:
- помогает бороться с наследованием или реализацией ненужной функциональности;
- даёт возможность спроектировать модули так, чтобы их затрагивали изменения только тех интерфейсов, которые они действительно реализуют;
- снижает зацепление модулей;
- уничтожает наследование ради наследования, поощряет использование композиции;
- позволяет выявлять более высокие абстракции и находить неочевидные связи между сущностями.

### D — Принцип инверсии зависимостей (Dependency Inversion Principle, DIP):
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Использование инверсии контроля (Inversion of Control) и внедрения зависимостей (Dependency Injection), чтобы зависимости между модулями и компонентами основывались на абстракциях, а не на конкретных реализациях.

Принцип инверсии зависимостей:
- вводит правила и ограничения для зависимости одних модулей от других;
- снижает зацепление модулей;
- делает тестирование модулей проще;
- позволяет проектировать систему так, чтобы модули были заменяемы на другие.

## KISS (Keep it simple stupid)
Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей и следует избегать ненужной сложности. 
Повышает надежность, облегчает разработку, поддержку кода.

## DRY (Don't repeat yourself)
Избагеть дублирования кода.
Если код не дублируется, то для изменения логики достаточно внесения исправлений всего в одном месте. Также проще тестировать одну (пусть и более сложную) функцию, а не набор из десятков однотипных.

## YAGNI (You aren't gonna need it)
Отказ от излишней функциональности, следование ТЗ.
