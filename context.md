## Контекст выполнения в JS

*Контекст выполнения* (execution context) - это концепция, описваюшая окружение, в котором производится выполненте кода на JS. Код всегда выполняется внутри некоего контекста.

*Контекст выполнения* в JS используется для того, чтобы отслеживать ход выполнения кода. Именно с его помощью определяется доступное окружение на текущем этапе выполнения программы.

По сути, *контекст выполенения* представляет собой обертку или окружение для исполняемого кода, содержащую некоторые вспомогательные элементы для отслеживания программы, часть из которых даже достижима напрямую из кода (например, значение специального объекта this)

### Виды контекста выполнения

В JS существует три вида контекстов выполнения:
1. Глобальный контекст выполнения
2. Функциональный контекст выполнения
3. Контекст выполнения функции eval

### Жизненный цикл контекста выполнения в JS

Каждый контекст выполнения в JS проходит три этапа:
  #### 1. Этап создания
  Этап создания проходит во время вызова функции, но до начала ее выполнения. На этом этапе движок JS сканирует код функции, создает лексическое окружение и инициализирует его (т.е. записывает все аргументы, переменные, внутренние функции, после чего определяет ссылку на внешнее лексическое окружение и задает значение `this`)
  #### 2. Этап запуска
  На этапе запуска код исполняется. По мере исполнения кода JS может создавать и другие контексты выполнения. 
  #### 3. Этап уничтожения
  После завершения исполнения всего кода в рамках текущего контекста выполнения он "выбрасывается" из стека вызовов и уничтожается.

### Способы выполнения кода в JS
- вызвать функцию: контекст выполнения будет глобальным
- вызвать метод объекта
  `this === object`, определяется в моменты **вызова**. При вызове отдельно от объекта (через присвоение переменной) `this === window`
- использовать функцию конструктор, класс
  `this` будет равен инстансу. Конструктор создает пустой объект, он присываевается this. Выполняется код функции (модифицирует `this`). Возвращается `this`
- непрямой вызов функции
  - `call()`, `apply()`
  первым аргументом принимают `this`, далее аргументы вызываемой функции: `call()` через запятую, `apply()` массивом зависимостей
  - `bind()` 
  привязывает контекст *жестко*, не вызывает функцию сразу, возвращает новую функцию с привязанным контекстом. Контекст у этой функции невозможно изменить другим `bind()`
  - arrow functions
  не имеют своего контекста, берут ближайший по иерархии контекст:
